// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Camera.proto

#ifndef PROTOBUF_Camera_2eproto__INCLUDED
#define PROTOBUF_Camera_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "Point.pb.h"
// @@protoc_insertion_point(includes)

namespace ElVis {
namespace Serialization {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_Camera_2eproto();
void protobuf_AssignDesc_Camera_2eproto();
void protobuf_ShutdownFile_Camera_2eproto();

class Camera;

// ===================================================================

class Camera : public ::google::protobuf::Message {
 public:
  Camera();
  virtual ~Camera();

  Camera(const Camera& from);

  inline Camera& operator=(const Camera& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Camera& default_instance();

  void Swap(Camera* other);

  // implements Message ----------------------------------------------

  inline Camera* New() const { return New(NULL); }

  Camera* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Camera& from);
  void MergeFrom(const Camera& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Camera* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ElVis.Serialization.Point eye = 1;
  bool has_eye() const;
  void clear_eye();
  static const int kEyeFieldNumber = 1;
  const ::ElVis::Serialization::Point& eye() const;
  ::ElVis::Serialization::Point* mutable_eye();
  ::ElVis::Serialization::Point* release_eye();
  void set_allocated_eye(::ElVis::Serialization::Point* eye);

  // optional .ElVis.Serialization.Point lookAt = 2;
  bool has_lookat() const;
  void clear_lookat();
  static const int kLookAtFieldNumber = 2;
  const ::ElVis::Serialization::Point& lookat() const;
  ::ElVis::Serialization::Point* mutable_lookat();
  ::ElVis::Serialization::Point* release_lookat();
  void set_allocated_lookat(::ElVis::Serialization::Point* lookat);

  // optional .ElVis.Serialization.Point up = 3;
  bool has_up() const;
  void clear_up();
  static const int kUpFieldNumber = 3;
  const ::ElVis::Serialization::Point& up() const;
  ::ElVis::Serialization::Point* mutable_up();
  ::ElVis::Serialization::Point* release_up();
  void set_allocated_up(::ElVis::Serialization::Point* up);

  // optional .ElVis.Serialization.Point u = 4;
  bool has_u() const;
  void clear_u();
  static const int kUFieldNumber = 4;
  const ::ElVis::Serialization::Point& u() const;
  ::ElVis::Serialization::Point* mutable_u();
  ::ElVis::Serialization::Point* release_u();
  void set_allocated_u(::ElVis::Serialization::Point* u);

  // optional .ElVis.Serialization.Point v = 5;
  bool has_v() const;
  void clear_v();
  static const int kVFieldNumber = 5;
  const ::ElVis::Serialization::Point& v() const;
  ::ElVis::Serialization::Point* mutable_v();
  ::ElVis::Serialization::Point* release_v();
  void set_allocated_v(::ElVis::Serialization::Point* v);

  // optional .ElVis.Serialization.Point w = 6;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 6;
  const ::ElVis::Serialization::Point& w() const;
  ::ElVis::Serialization::Point* mutable_w();
  ::ElVis::Serialization::Point* release_w();
  void set_allocated_w(::ElVis::Serialization::Point* w);

  // optional double field_of_view = 7;
  void clear_field_of_view();
  static const int kFieldOfViewFieldNumber = 7;
  double field_of_view() const;
  void set_field_of_view(double value);

  // optional double aspect_ratio = 8;
  void clear_aspect_ratio();
  static const int kAspectRatioFieldNumber = 8;
  double aspect_ratio() const;
  void set_aspect_ratio(double value);

  // optional float near = 9;
  void clear_near();
  static const int kNearFieldNumber = 9;
  float near() const;
  void set_near(float value);

  // optional float far = 10;
  void clear_far();
  static const int kFarFieldNumber = 10;
  float far() const;
  void set_far(float value);

  // @@protoc_insertion_point(class_scope:ElVis.Serialization.Camera)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::ElVis::Serialization::Point* eye_;
  ::ElVis::Serialization::Point* lookat_;
  ::ElVis::Serialization::Point* up_;
  ::ElVis::Serialization::Point* u_;
  ::ElVis::Serialization::Point* v_;
  ::ElVis::Serialization::Point* w_;
  double field_of_view_;
  double aspect_ratio_;
  float near_;
  float far_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_Camera_2eproto();
  friend void protobuf_AssignDesc_Camera_2eproto();
  friend void protobuf_ShutdownFile_Camera_2eproto();

  void InitAsDefaultInstance();
  static Camera* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Camera

// optional .ElVis.Serialization.Point eye = 1;
inline bool Camera::has_eye() const {
  return !_is_default_instance_ && eye_ != NULL;
}
inline void Camera::clear_eye() {
  if (GetArenaNoVirtual() == NULL && eye_ != NULL) delete eye_;
  eye_ = NULL;
}
inline const ::ElVis::Serialization::Point& Camera::eye() const {
  // @@protoc_insertion_point(field_get:ElVis.Serialization.Camera.eye)
  return eye_ != NULL ? *eye_ : *default_instance_->eye_;
}
inline ::ElVis::Serialization::Point* Camera::mutable_eye() {
  
  if (eye_ == NULL) {
    eye_ = new ::ElVis::Serialization::Point;
  }
  // @@protoc_insertion_point(field_mutable:ElVis.Serialization.Camera.eye)
  return eye_;
}
inline ::ElVis::Serialization::Point* Camera::release_eye() {
  
  ::ElVis::Serialization::Point* temp = eye_;
  eye_ = NULL;
  return temp;
}
inline void Camera::set_allocated_eye(::ElVis::Serialization::Point* eye) {
  delete eye_;
  eye_ = eye;
  if (eye) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ElVis.Serialization.Camera.eye)
}

// optional .ElVis.Serialization.Point lookAt = 2;
inline bool Camera::has_lookat() const {
  return !_is_default_instance_ && lookat_ != NULL;
}
inline void Camera::clear_lookat() {
  if (GetArenaNoVirtual() == NULL && lookat_ != NULL) delete lookat_;
  lookat_ = NULL;
}
inline const ::ElVis::Serialization::Point& Camera::lookat() const {
  // @@protoc_insertion_point(field_get:ElVis.Serialization.Camera.lookAt)
  return lookat_ != NULL ? *lookat_ : *default_instance_->lookat_;
}
inline ::ElVis::Serialization::Point* Camera::mutable_lookat() {
  
  if (lookat_ == NULL) {
    lookat_ = new ::ElVis::Serialization::Point;
  }
  // @@protoc_insertion_point(field_mutable:ElVis.Serialization.Camera.lookAt)
  return lookat_;
}
inline ::ElVis::Serialization::Point* Camera::release_lookat() {
  
  ::ElVis::Serialization::Point* temp = lookat_;
  lookat_ = NULL;
  return temp;
}
inline void Camera::set_allocated_lookat(::ElVis::Serialization::Point* lookat) {
  delete lookat_;
  lookat_ = lookat;
  if (lookat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ElVis.Serialization.Camera.lookAt)
}

// optional .ElVis.Serialization.Point up = 3;
inline bool Camera::has_up() const {
  return !_is_default_instance_ && up_ != NULL;
}
inline void Camera::clear_up() {
  if (GetArenaNoVirtual() == NULL && up_ != NULL) delete up_;
  up_ = NULL;
}
inline const ::ElVis::Serialization::Point& Camera::up() const {
  // @@protoc_insertion_point(field_get:ElVis.Serialization.Camera.up)
  return up_ != NULL ? *up_ : *default_instance_->up_;
}
inline ::ElVis::Serialization::Point* Camera::mutable_up() {
  
  if (up_ == NULL) {
    up_ = new ::ElVis::Serialization::Point;
  }
  // @@protoc_insertion_point(field_mutable:ElVis.Serialization.Camera.up)
  return up_;
}
inline ::ElVis::Serialization::Point* Camera::release_up() {
  
  ::ElVis::Serialization::Point* temp = up_;
  up_ = NULL;
  return temp;
}
inline void Camera::set_allocated_up(::ElVis::Serialization::Point* up) {
  delete up_;
  up_ = up;
  if (up) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ElVis.Serialization.Camera.up)
}

// optional .ElVis.Serialization.Point u = 4;
inline bool Camera::has_u() const {
  return !_is_default_instance_ && u_ != NULL;
}
inline void Camera::clear_u() {
  if (GetArenaNoVirtual() == NULL && u_ != NULL) delete u_;
  u_ = NULL;
}
inline const ::ElVis::Serialization::Point& Camera::u() const {
  // @@protoc_insertion_point(field_get:ElVis.Serialization.Camera.u)
  return u_ != NULL ? *u_ : *default_instance_->u_;
}
inline ::ElVis::Serialization::Point* Camera::mutable_u() {
  
  if (u_ == NULL) {
    u_ = new ::ElVis::Serialization::Point;
  }
  // @@protoc_insertion_point(field_mutable:ElVis.Serialization.Camera.u)
  return u_;
}
inline ::ElVis::Serialization::Point* Camera::release_u() {
  
  ::ElVis::Serialization::Point* temp = u_;
  u_ = NULL;
  return temp;
}
inline void Camera::set_allocated_u(::ElVis::Serialization::Point* u) {
  delete u_;
  u_ = u;
  if (u) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ElVis.Serialization.Camera.u)
}

// optional .ElVis.Serialization.Point v = 5;
inline bool Camera::has_v() const {
  return !_is_default_instance_ && v_ != NULL;
}
inline void Camera::clear_v() {
  if (GetArenaNoVirtual() == NULL && v_ != NULL) delete v_;
  v_ = NULL;
}
inline const ::ElVis::Serialization::Point& Camera::v() const {
  // @@protoc_insertion_point(field_get:ElVis.Serialization.Camera.v)
  return v_ != NULL ? *v_ : *default_instance_->v_;
}
inline ::ElVis::Serialization::Point* Camera::mutable_v() {
  
  if (v_ == NULL) {
    v_ = new ::ElVis::Serialization::Point;
  }
  // @@protoc_insertion_point(field_mutable:ElVis.Serialization.Camera.v)
  return v_;
}
inline ::ElVis::Serialization::Point* Camera::release_v() {
  
  ::ElVis::Serialization::Point* temp = v_;
  v_ = NULL;
  return temp;
}
inline void Camera::set_allocated_v(::ElVis::Serialization::Point* v) {
  delete v_;
  v_ = v;
  if (v) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ElVis.Serialization.Camera.v)
}

// optional .ElVis.Serialization.Point w = 6;
inline bool Camera::has_w() const {
  return !_is_default_instance_ && w_ != NULL;
}
inline void Camera::clear_w() {
  if (GetArenaNoVirtual() == NULL && w_ != NULL) delete w_;
  w_ = NULL;
}
inline const ::ElVis::Serialization::Point& Camera::w() const {
  // @@protoc_insertion_point(field_get:ElVis.Serialization.Camera.w)
  return w_ != NULL ? *w_ : *default_instance_->w_;
}
inline ::ElVis::Serialization::Point* Camera::mutable_w() {
  
  if (w_ == NULL) {
    w_ = new ::ElVis::Serialization::Point;
  }
  // @@protoc_insertion_point(field_mutable:ElVis.Serialization.Camera.w)
  return w_;
}
inline ::ElVis::Serialization::Point* Camera::release_w() {
  
  ::ElVis::Serialization::Point* temp = w_;
  w_ = NULL;
  return temp;
}
inline void Camera::set_allocated_w(::ElVis::Serialization::Point* w) {
  delete w_;
  w_ = w;
  if (w) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ElVis.Serialization.Camera.w)
}

// optional double field_of_view = 7;
inline void Camera::clear_field_of_view() {
  field_of_view_ = 0;
}
inline double Camera::field_of_view() const {
  // @@protoc_insertion_point(field_get:ElVis.Serialization.Camera.field_of_view)
  return field_of_view_;
}
inline void Camera::set_field_of_view(double value) {
  
  field_of_view_ = value;
  // @@protoc_insertion_point(field_set:ElVis.Serialization.Camera.field_of_view)
}

// optional double aspect_ratio = 8;
inline void Camera::clear_aspect_ratio() {
  aspect_ratio_ = 0;
}
inline double Camera::aspect_ratio() const {
  // @@protoc_insertion_point(field_get:ElVis.Serialization.Camera.aspect_ratio)
  return aspect_ratio_;
}
inline void Camera::set_aspect_ratio(double value) {
  
  aspect_ratio_ = value;
  // @@protoc_insertion_point(field_set:ElVis.Serialization.Camera.aspect_ratio)
}

// optional float near = 9;
inline void Camera::clear_near() {
  near_ = 0;
}
inline float Camera::near() const {
  // @@protoc_insertion_point(field_get:ElVis.Serialization.Camera.near)
  return near_;
}
inline void Camera::set_near(float value) {
  
  near_ = value;
  // @@protoc_insertion_point(field_set:ElVis.Serialization.Camera.near)
}

// optional float far = 10;
inline void Camera::clear_far() {
  far_ = 0;
}
inline float Camera::far() const {
  // @@protoc_insertion_point(field_get:ElVis.Serialization.Camera.far)
  return far_;
}
inline void Camera::set_far(float value) {
  
  far_ = value;
  // @@protoc_insertion_point(field_set:ElVis.Serialization.Camera.far)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace Serialization
}  // namespace ElVis

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Camera_2eproto__INCLUDED
